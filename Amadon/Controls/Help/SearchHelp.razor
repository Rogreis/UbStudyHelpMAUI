@using Blazorise

<p>Amadon search engine is based on <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html">Apache Lucene</a>, a powerful search library, which can provide advanced search functionality to any application. This help guide will walk you through the basics of using the Lucene.net based search engine in our application.</p>
<ImageForHelp RelativeUrl="images/Search.png" Size="ImageForHelp.ImageSize.Full" Alt="The search engine"></ImageForHelp>


<Accordion>

    <Collapse Visible="@collapse1Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is1">
                <AccordionToggle>Getting Started</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
           
            <HelpTable Titles="@Titles" Lines="@LinesForBasic"></HelpTable>

            <h3>Basic search examples</h3>
            <HelpTable MaxColumns=2 FirstColumnAsHeader=false Titles="@TitleForBasicExamples" Lines="@LinesBasicExamples"></HelpTable>

            <h3>Search Operators</h3>
            <p>Our search engine supports several search operators:</p>
            <HelpTable Titles="@Titles" Lines="@LinesForSearchOperator"></HelpTable>

        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse5Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>More About Wildcards</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <h3>More About Wildcard Searches:</h3>
            <HelpTable MaxColumns=2 FirstColumnAsHeader=false Titles="@TitleForBasicExamples" Lines="@LinesForWildcards"></HelpTable>

            <h3>Tips for Effective Wildcard Searches:</h3>
            <HelpTable MaxColumns=2 FirstColumnAsHeader=false Titles="@TitleTipsForWildcards" Lines="@LinesTipsForWildcards"></HelpTable>
        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse2Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is1">
                <AccordionToggle>Search Tips</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <HelpTable Titles="@Titles" Lines="@LinesSearchingTips"></HelpTable>
        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse3Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is1">
                <AccordionToggle>Troubleshooting</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <p>If you&#39;re having issues with the search functionality, try these steps:</p>
            <HelpTable MaxColumns=2 FirstColumnAsHeader=false Titles="@TitleTipsGrouping" Lines="@LinesForTroubleshooting"></HelpTable>
            <p>Remember, the aim of the search is to help you find exactly what you&#39;re looking for in the most efficient way. Happy searching!</p>
        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse6Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>Similar (Fuzzy) Searches</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <HelpTable Titles="@Titles" Lines="@LinesForSimilar"></HelpTable>
            <p><em>The default that is used if the parameter is not given is 0.5.</em></p>
        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse7Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>Proximity Searches</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <p>You can try finding words are a within a specific distance away. To do a proximity search use the tilde, "~", symbol at the end of a Phrase. For example to search for a "Jesus" and "God" within 10 or 2 words of each other in a document use the search:</p>
            <ul>
                <li>
                    <p>"Jesus God"~10 finds 117 paragraphs</p>
                </li>
                <li>
                    <p>"Jesus God"~2 finds 18 paragraphs</p>
                </li>
            </ul>
        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse8Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>Boosting a Term</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <p>To increase some term&#39;s relevance use the caret, "^", symbol with a boost factor (a number) at the end of the term you are searching. The higher the boost factor, the more relevant the term will be.</p>
            <p>Boosting allows you to control the relevance of a document by boosting its term. For example, if you are searching for <strong>Jesus God</strong> and you want the term "<strong>Jesus</strong>" to be more relevant boost it using the ^ symbol along with the boost factor next to the term. You would type:</p>
            <HelpTable Titles="@Titles" Lines="@LinesForBoosting"></HelpTable>
            <p>By default, the boost factor is 1. Although the boost factor must be positive, it can be less than 1 (e.g. 0.2)</p>
        </CollapseBody>
    </Collapse>
    
    <Collapse Visible="@collapse9Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>Boolean Operators</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <p>Boolean operators allow terms to be combined through logic operators. This search supports AND, "+", OR, NOT and "-" as Boolean operators. (Note: Boolean operators must be ALL CAPS).</p>
            <p>The OR operator is the default conjunction operator. This means that if there is no Boolean operator between two terms, the OR operator is used. The OR operator links two terms and finds a matching document if either of the terms exist in a document. This is equivalent to a union using sets. The symbol || can be used in place of the word OR.</p>
          <HelpTable Titles="@Titles" Lines="@LinesForBooleanOperator"></HelpTable>
       </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse10Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>Grouping</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <h3>Field Grouping</h3>
            <HelpTable MaxColumns=2 FirstColumnAsHeader=false Titles="@TitleTipsGrouping" Lines="@LinesForGrouping"></HelpTable>
            
        </CollapseBody>
    </Collapse>

    <Collapse Visible="@collapse11Visible">
        <CollapseHeader Class="HeaderColors">
            <Heading Size="HeadingSize.Is3">
                <AccordionToggle>Escaping Special Characters</AccordionToggle>
            </Heading>
        </CollapseHeader>
        <CollapseBody Class="AmadonDark">
            <p>Amadon search supports escaping special characters that are part of the query syntax. The current list special characters are</p>
            <ul>
                <li>
                    <ul>
                        <li><code>&amp; | ! ( ) { } [ ] ^ " ~ * ? : \</code></li>
                    </ul>
                </li>
            </ul>
            <p>To escape these character use the \ before the character. For example to search for <strong>[Revealed</strong> use the query:</p>
            <ul>
                <li><code>\[Revealed</code></li>
            </ul>
        </CollapseBody>
    </Collapse>

</Accordion>


@code {

    bool collapse1Visible = true;
    bool collapse2Visible = false;
    bool collapse3Visible = false;
    bool collapse4Visible = false;
    bool collapse5Visible = false;
    bool collapse6Visible = false;
    bool collapse7Visible = false;
    bool collapse8Visible = false;
    bool collapse9Visible = false;
    bool collapse10Visible = false;
    bool collapse11Visible = false;

    private List<string> Titles { get; set; } = new List<string>()
    {
        "Operator",
        "Description",
        "Example"
    };

    private List<string> TitleTipsForWildcards { get; set; } = new List<string>()
    {
        "Subject",
        "Description",
    };

    private List<string> TitleTipsGrouping { get; set; } = new List<string>()
    {
        "Subject",
        "Example"
    };

    private List<string> TitleForBasicExamples { get; set; } = new List<string>()
    {
        "For",
        "Type",
    };

    private List<List<string>> LinesForBoosting = new List<List<string>>()
    {
        new List<string>()
        {
            "^<number>",
            "This will make documents where the term Jesus appear more relevant",
            "Jesus^4 God"
        },
        new List<string>()
        {
            "^<number>",
            "Here the phrase has a bigger boost",
            "\"Jesus Christ\"^4 \"apostle Peter\""
        }
    };

    private List<List<string>> LinesForBasic = new List<List<string>>()
    {
        new List<string>()
        {
            "<type any word>",
            "Type your search term in the search box and press enter. You can search for a single word, a phrase, or use advanced queries described below",
            "Inqualified"
        },
    };

    private List<List<string>> LinesTipsForWildcards = new List<List<string>>()
    {
        new List<string>()
        {
            "Limit the Number of Wildcards",
            "Using too many ? characters can return a vast number of results, making it harder to find what you're looking for. It's best to use them sparingly and in combination with known characters.",
        },
        new List<string>()
        {
            "Position Matters",
            "The position of the ? character will determine which character it replaces. For instance, te?t will not return \"treat\", but t??t will.",
        },
        new List<string>()
        {
            "Conclusion",
            "The ? wildcard is a powerful tool in Amadon's search functionality, allowing users to find information even when they're unsure of the exact terms. By understanding and effectively using this feature, you can make your searches more flexible and comprehensive.",
        },
    };

    private List<List<string>> LinesForWildcards = new List<List<string>>()
    {
        new List<string>()
        {
            "The single character wildcard search looks for terms that match that with the single character replaced. For example, to search for \"absoluta\" or \"absolute\" you can use the search:",
            "absolut?",
        },
        new List<string>()
        {
            "Multiple character wildcard searches looks for 0 or more characters. For example, to search for absoluta, absolute or absoluteness, you can use the search:",
            "absolut*",
        },
        new List<string>()
        {
            "You can also use the wildcard searches in the middle of a term. The following example will find everything starting with abso and finishing with e.",
            "abso*e",
        },
    };

    private List<List<string>> LinesBasicExamples = new List<List<string>>()
    {
        new List<string>()
        {
            "To search for \"Jesus\", type Jesus en click search",
            "Jesus"
        },
        new List<string>()
        {
            "To search for the expression \"Christ Michael\", type the expression and click search",
            "\"Christ Michael\""
        },
        new List<string>()
        {
            "To search for two words ocurring in the same paragraph with any distance between both, type the following with attention that the word AND must be uppercase",
            "Jesus AND God"
        },
        new List<string>()
        {
            "A search mixing words and expressions is also possible, like the following where the expression \"My master delays his coming\" and the word God can be found in the same paragraph",
            "\"My master delays his coming\" AND God"
        },
        new List<string>()
        {
            "If you're unsure about a particular character in a word, replace it with ?. Example: Searching for te?t will return results like \"text\", \"tent\", and \"test\".",
            "te?t"
        },
        new List<string>()
        {
            "You can use multiple ? characters in a word to replace multiple unknown characters. Example: Searching for t??t might return \"treat\", \"tryst\", and \"troth\".",
            "t??t"
        },
        new List<string>()
        {
            "Combine the ? wildcard with known characters to narrow down your search results. Example: Searching for tr?st will specifically return \"tryst\".",
            "tr?st"
        },
    };

    private List<List<string>> LinesForSearchOperator = new List<List<string>>()
    {
        new List<string>()
        {
            "AND",
            "This operator, always using upper letters, matches documents where both terms exist anywhere in the text. To search for documents that contain \"Inqualified\" and \"Absolute\", use:",
            "Inqualified AND Absolute"
        },
        new List<string>()
        {
            "OR",
            "This operator, always using upper letters, matches documents where either term exists anywhere in the text. To search for documents that contain \"Inqualified\" or \"Absolute\", use:",
            "Inqualified OR Absolute"
        },
        new List<string>()
        {
            "NOT",
            "This operator, always using upper letters, excludes documents that contain the term after NOT. To search for documents that contain \"Inqualified\" but not \"Absolut\", use: ",
            "Inqualified NOT Absolute"
        },
        new List<string>()
        {
            "+",
            "This operator makes a term mandatory, or \"must appear\" in the result. To search for documents that must contain \"Inqualified\", use:, use: ",
            "+Inqualified"
        },
        new List<string>()
        {
            "-",
            "(Must Not)</strong>: This operator requires that the term must not appear in the document. To search for documents that must not contain \"Inqualified\", use:",
            "-Inqualified"
        },
        new List<string>()
        {
            "*",
            "The wildcard operator can be used to search for partial words. For instance, to find documents containing words that start with \"inqua\", use:",
            "inqua*"
        },
        new List<string>()
        {
            "\"<any phrase>\"",
            "This operator can be used when you are not sure of the correct spelling. To perform a similar (fuzzy) search, use:",
            "\"Seven Circles\""
        },
    };

    private List<List<string>> LinesSearchingTips = new List<List<string>>()
    {
        new List<string>()
        {
            "case",
            "Lucene.net search is case insensitive. For example, searching for \"INFINITE\" will also return \"INFINITE\" or \"infinite\" or even mixed like \"Infinite\"",
            "INFINITE"
        },
        new List<string>()
        {
            "Special",
            "Special characters need to be escaped with \"\". For example, to search for \"(1+1)=2\", use:",
            "\\(1\\+1\\)=2"
        },
        new List<string>()
        {
            "* alone",
            "Avoid using a single wildcard (*) as a search term, as it may return too many results and slow down the search",
            "*"
        },
    };

    private List<List<string>> LinesForTroubleshooting = new List<List<string>>()
    {
        new List<string>()
        {
            "Spelling",
            "Check your search term for typos or spelling mistakes",
        },
        new List<string>()
        {
            "Operators",
            "If you&#39;re using search operators, ensure that they&#39;re formatted correctly",
        },
        new List<string>()
        {
            "Too many results",
            "If the search is returning too many irrelevant results, try adding more specific terms or using the AND or \"+\" operator to narrow down the results, or reduce the search to use only some book parts",
        },
        new List<string>()
        {
            "Few results",
            "If the search is returning too few or no results, try using broader terms or the OR operator to widen the search; check also if all the books parts are set to be used in the search",
        },
    };

    private List<List<string>> LinesForSimilar = new List<List<string>>()
    {
        new List<string>()
        {
            "~",
            "To do a similar search use the tilde, \"~\", symbol at the end of a Single word Term. For example to search for a term similar in spelling to \"abso\" use the fuzzy search:",
            "abso~"
        },
        new List<string>()
        {
            "~",
            "To find terms like foam and roma:",
            "roam~"
        },
        new List<string>()
        {
            "~",
            "An additional (optional) parameter can specify the required similarity. The value is between 0 and 1, with a value closer to 1 only terms with a higher similarity will be matched. For example:",
            "roam~0.8"
        },
    };

    private List<List<string>> LinesForBooleanOperator = new List<List<string>>()
    {
        new List<string>()
        {
            "OR",
            "To search for documents that contain either \"Christ Michael\" or just \"Jesus\" use the left example:",
            "\"Christ Michael\" OR Jesus"
        },
        new List<string>()
        {
            "AND",
            "The AND operator matches documents where both terms exist anywhere in the text of a single document. This is equivalent to an intersection using sets. The symbol &amp;&amp; can be used in place of the word AND. To search for documents that contain \"Christ Michael\" and \"Jesus of Nazareth\" use the example:",
            "\"Christ Michael\" AND \"Jesus of Nazareth\""
        },
        new List<string>()
        {
            "+",
            "The \"+\" or required operator requires that the term after the \"+\" symbol exist somewhere in a the field of a single document. To search for documents that must contain \"Christ\" and may contain \"Nebadon\" use the left example:",
            "+Christ Nebadon"
        },
        new List<string>()
        {
            "NOT",
            "The NOT operator excludes documents that contain the term after NOT. This is equivalent to a difference using sets. To search for documents that contain \"Christ Michael\" but not \"Jesus of Nazareth\" use the left example:",
            "\"Christ Michael\" NOT \"Jesus of Nazareth\""
        },
        new List<string>()
        {
            "!",
            "Same as NOT above, it can be used in place of the word NOT. To search for documents that contain \"Christ Michael\" but not \"Jesus of Nazareth\" use the left example:",
            "\"Christ Michael\" !\"Jesus of Nazareth\""
        },
        new List<string>()
        {
            "-",
            "The \"-\" or prohibit operator excludes documents that contain the term after the \"-\" symbol. To search for documents that contain \"Christ Michael\" but not \"Jesus of Nazareth\" use the query:",
            "\"Christ Michael\" - \"Jesus of Nazareth\""
        },
    };

    private List<List<string>> LinesForGrouping = new List<List<string>>()
    {
        new List<string>()
        {
            "You can use parentheses to group clauses to form sub queries. This can be very useful if you want to control the boolean logic for a query. To search for either \"Christ\" or \"Nebadon\" and \"Gabriel\", eliminating any confusion and making sure that paragraphs must have \"Gabriel\" and either term \"Christ\" or \"Nebadon\" may exist, use the query:",
            "(Christ OR Nebadon) AND Gabriel"
        },
        new List<string>()
        {
            "Parentheses also can be used to group multiple clauses to a single field. To search for a title that contains both the word \"Buddha\" and the phrase \"Genghis Khan\" use the query:",
            "(+Buddha+\"Genghis Khan\")"
        },
    };





}
